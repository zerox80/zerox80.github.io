<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Dateisystemâ€‘Typen</title>
<link href="../../assets/css/style.css" rel="stylesheet"/>
<script defer="" src="../../assets/js/main.js"></script>
<meta content="Dateisystemâ€‘Typen" property="og:title"/><meta content="summary" name="twitter:card"/></head>
<body>
<header class="site-header">
<div class="container">
<h1>Linux Lernportal</h1>
<nav class="top-nav">
<a href="../../index.html">Start</a>
<a class="active" href="../index.html">LPIC-1</a>
<a class="disabled" href="#" title="Bald verfÃ¼gbar">LPIC-2</a>
<a class="disabled" href="#" title="Bald verfÃ¼gbar">LPIC-3</a>
<a href="../../search.html">Suche</a><a href="../../lpic-1/glossar.html">Glossar</a><button class="btn" id="themeToggle">ğŸŒ“</button>
</nav>
</div>
</header>
<main class="container">
<div class="breadcrumbs"><a href="../../index.html">Start</a> â–¸ <a href="../index.html">LPICâ€‘1</a> â–¸ <a href="../dateisysteme-fhs.html">Dateisysteme &amp; FHS</a> â–¸ Typen</div>
<h2>Dateisystemâ€‘Typen</h2>
<div class="layout">
<aside class="sidebar card">
<h3>Unterthemen</h3>
<div class="card-body">
<nav class="toc">
<a href="fhs.html">FHS Ãœberblick</a>
<a href="mount-und-fstab.html">Mount &amp; /etc/fstab</a>
<a href="dateisystem-werkzeuge.html">Dateisystemâ€‘Werkzeuge</a>
<a class="active" href="dateisystem-typen.html">Dateisystemâ€‘Typen</a>
<a href="speicheranalyse.html">Speicheranalyse</a>
<a href="inodes-und-links.html">Inodes &amp; Links</a>
<a href="quotas.html">Quotas</a>
<a href="partitionen-und-swap.html">Partitionen &amp; Swap</a>
<a href="labels-und-uuid.html">Labels &amp; UUID</a>
<a href="mount-optionen-und-sicherheit.html">Mountâ€‘Optionen &amp; Sicherheit</a>
<a href="dateisystem-attribute.html">Dateisystemâ€‘Attribute</a>
<a href="tmpfs-und-bind-mounts.html">tmpfs &amp; Bindâ€‘Mounts</a>
</nav>
</div>
</aside>
<article class="content">
<div class="card block"><h3>Lernziele</h3><div class="card-body"><ul>
<li>Wesentliche Eigenschaften von ext4, XFS, Btrfs im Detail erklÃ¤ren und geeignete Einsatzszenarien auswÃ¤hlen.</li>
<li>KompatibilitÃ¤tsaspekte (FAT, exFAT, NTFS) im Linuxâ€‘Kontext einordnen.</li>
<li>Dateisysteme erstellen, prÃ¼fen, einhÃ¤ngen und optimieren (mkfs, fsck, tune2fs/xfs_admin/btrfs).</li>
<li>Snapshots, Subvolumes, Quotas und Mountâ€‘Optionen zielgerichtet einsetzen.</li>
</ul></div></div>
<div class="card block"><h3>KurzÃ¼berblick</h3><div class="card-body">
<table>
<tr><th>Typ</th><th>StÃ¤rken</th><th>Wann einsetzen</th><th>Hinweise</th></tr>
<tr><td>ext4</td><td>Sehr stabil, breite Toolâ€‘UnterstÃ¼tzung</td><td>Allround, VMs, Desktops, kleine bis mittlere Server</td><td>Journaling, Delayed Allocation, maturing seit Jahren</td></tr>
<tr><td>XFS</td><td>Hohe Performance bei groÃŸen Dateien/ParallelitÃ¤t</td><td>Medien, Backups, Datenbanken (groÃŸe Files), NVMe/RAID</td><td>Onlineâ€‘Defrag, sehr gute Skalierung; weniger gut bei vielen Miniâ€‘Files</td></tr>
<tr><td>Btrfs</td><td>Snapshots, Subvolumes, COW, Checksums</td><td>Workstations, Containerâ€‘Hosts, Rollbackâ€‘Szenarien</td><td>Featureâ€‘reich, erfordert VerstÃ¤ndnis (COWâ€‘Tuning, RAIDâ€‘Profile)</td></tr>
<tr><td>FAT/exFAT</td><td>Breite OSâ€‘KompatibilitÃ¤t</td><td>WechseldatentrÃ¤ger, Kameras, Austausch mit Windows/macOS</td><td>Keine POSIXâ€‘Rechte, kaum Features</td></tr>
<tr><td>NTFS</td><td>Kompat. zu Windows</td><td>Dualâ€‘Boot, Austausch</td><td>Unter Linux via ntfsâ€‘3g; Performance/Featureâ€‘Gap zu nativem ext4/xfs</td></tr>
<tr><td>ZFS</td><td>Endâ€‘toâ€‘End Checksums, Snapshots, RAIDâ€‘Z, Send/Receive</td><td>Storageâ€‘Server, Backups, Datenâ€‘IntegritÃ¤t im Fokus</td><td>Nicht im Kernel enthalten (Lizenz), DKMS/Outâ€‘ofâ€‘Tree; RAMâ€‘hungrig</td></tr>
</table>
</div></div>
<div class="card block"><h3>Theorie &amp; Konzepte</h3><div class="card-body">
<h4>Journaling &amp; Konsistenz</h4>
<p>Moderne FS nutzen Journaling (z. B. ext4, XFS), um Metadatenâ€‘Konsistenz nach AbstÃ¼rzen sicherzustellen. <em>Ordered</em> vs. <em>Writeback</em> vs. <em>Data=journal</em> beeinflusst Sicherheitsâ€‘/Performanceâ€‘Tradeoffs.</p>
<h4>Copyâ€‘onâ€‘Write (COW)</h4>
<p>Btrfs schreibt Ã„nderungen in neue BlÃ¶cke, ermÃ¶glicht schnelle Snapshots/Clones und PrÃ¼fsummen fÃ¼r Daten/Metadaten. Nachteil: Randomâ€‘Writeâ€‘Workloads kÃ¶nnen fragmentieren; Workarounds z. B. <code>nodatacow</code> fÃ¼r VMâ€‘Images.</p>
<h4>Inodes, BlockgrÃ¶ÃŸen, Allokationsstrategien</h4>
<p>ext4 nutzt Extents/Delayed Allocation; XFS hat Variable Extents und starke Parallelisierung; Btrfs arbeitet mit Bâ€‘Trees fÃ¼r nahezu alles (Subvolumes, Snapshots, Quotas).</p>
</div></div>
<div class="card block"><h3>Praxis: Anlegen, PrÃ¼fen, EinhÃ¤ngen</h3><div class="card-body"><pre><code>
 # ext4 anlegen und prÃ¼fen
 sudo mkfs.ext4 -L data /dev/sdb1
 sudo tune2fs -l /dev/sdb1 | grep "Filesystem features"
 sudo e2fsck -f /dev/sdb1

 # XFS anlegen und prÃ¼fen
 sudo mkfs.xfs -L media /dev/sdc1
 sudo xfs_info /mnt
 sudo xfs_repair -n /dev/sdc1   # Readâ€‘only Check

 # Btrfs anlegen (mit Label) und Subvolume nutzen
 sudo mkfs.btrfs -L bdata /dev/sdd1
 sudo mount /dev/sdd1 /mnt
 sudo btrfs subvolume create /mnt/@root
 sudo umount /mnt &amp;&amp; sudo mount -o subvol=@root /dev/sdd1 /mnt

 # Mount in /etc/fstab (Beispiele)
 UUID=...  /data  ext4  defaults,noatime,commit=60  0 2
 UUID=...  /media xfs   defaults,inode64,discard    0 0
 UUID=...  /       btrfs subvol=@root,compress=zstd 0 0
 </code></pre></div></div>
<div class="card block"><h3>Best Practices</h3><div class="card-body"><ul>
<li><strong>ext4</strong>: solide Defaultâ€‘Wahl. FÃ¼r viele kleine Dateien ggf. <code>dir_index</code> aktiv, <code>noatime</code> Mount, regelmÃ¤ÃŸige <code>fsck</code> Checks.</li>
<li><strong>XFS</strong>: ideal fÃ¼r groÃŸe Dateien/hohen Durchsatz. Auf genÃ¼gend RAM und aktuelle Tools achten; Onlineâ€‘Defrag bei Fragmentierung verwenden.</li>
<li><strong>Btrfs</strong>: Snapshots fÃ¼r Rollbacks, <code>compress=zstd</code> fÃ¼r Platz/Performance. FÃ¼r VMâ€‘Images <code>nodatacow</code> oder separater Subvolumeâ€‘Pfad.</li>
<li><strong>Wechselmedien</strong>: exFAT fÃ¼r breite KompatibilitÃ¤t; Sicherheitsâ€‘/Rechtebedarf vorher klÃ¤ren.</li>
</ul></div></div>
<div class="card block"><h3>Cheatsheet</h3><div class="card-body"><pre><code>
 # Ãœbersicht unterstÃ¼tzen
 lsblk -f           # Typ, Label, UUID
 blkid              # UUID/Labels anzeigen

 # Erstellung
 mkfs.ext4 /dev/XYZ
 mkfs.xfs  /dev/XYZ
 mkfs.btrfs /dev/XYZ

 # Infos &amp; Tuning
 dumpe2fs -h /dev/XYZ
 xfs_info /mountpoint
 btrfs filesystem df /mountpoint

 # Snapshots (Btrfs)
 btrfs subvolume snapshot /mnt/@root /mnt/@root-snap

 # Quotas
 xfs_quota -x -c "report" /mountpoint
 btrfs qgroup show /mountpoint
 </code></pre></div></div>
<div class="card block"><h3>Tuning: ext4, XFS, Btrfs</h3><div class="card-body">
<h4>ext4</h4>
<ul>
<li><code>noatime</code>/<code>relatime</code>: reduziert Metadatenâ€‘Writes.</li>
<li><code>commit=60</code>: Journalâ€‘Commit alle 60s â€“ hÃ¶herer Durchsatz, etwas mehr Risiko.</li>
<li><code>data=ordered</code> (Default) statt <code>writeback</code> fÃ¼r sicherere Konsistenz.</li>
<li><code>dir_index</code> fÃ¼r schnellere Verzeichnisauflistung.</li>
<li>Auf neuen FS: <code>metadata_csum</code>, <code>64bit</code> Features via <code>tune2fs</code>.</li>
</ul>
<pre><code>UUID=... /data ext4 defaults,noatime,commit=60 0 2
mount | grep " /data "
            </code></pre>
<h4>XFS</h4>
<ul>
<li><code>inode64</code> fÃ¼r groÃŸe Dateisysteme.</li>
<li><code>allocsize=</code> fÃ¼r Streaming/Backupâ€‘Workloads testen.</li>
<li>SSD: periodisches <code>fstrim</code> statt dauerhaftem <code>discard</code>.</li>
<li>Onlineâ€‘Defrag: <code>xfs_fsr</code>/<code>xfs_spaceman</code>.</li>
</ul>
<pre><code>UUID=... /media xfs defaults,inode64 0 0
xfs_info /media
            </code></pre>
<h4>Btrfs</h4>
<ul>
<li><code>compress=zstd</code> hÃ¤ufig sinnvoll (Platz/IO sparen).</li>
<li>Subvolumes fÃ¼r Trennung (<code>@root</code>, <code>@home/@data</code>).</li>
<li>FÃ¼r VMâ€‘Images/DB: <code>nodatacow</code> bzw. <code>chattr +C</code> nutzen.</li>
<li>Gezielte Balance (<code>btrfs balance start -dusage=...</code>), nicht blind.</li>
</ul>
<pre><code>UUID=... / btrfs subvol=@root,compress=zstd,ssd,space_cache=v2 0 0
btrfs filesystem df /
            </code></pre>
</div></div>
<div class="card block"><h3>RAID &amp; Layering</h3><div class="card-body">
<p>Die Dateisystemwahl hÃ¤ngt stark von darunterliegenden Layern ab (MDâ€‘RAID, LVM, HWâ€‘RAID, LUKS, Thinâ€‘Provisioning).</p>
<ul>
<li><strong>Writeâ€‘Hole &amp; Journaling:</strong> RAID5/6 mit COWâ€‘FS (Btrfs) vs. MDâ€‘RAID abwÃ¤gen (IntegritÃ¤t vs. Performance).</li>
<li><strong>Alignment:</strong> <em>stride/stripeâ€‘width</em> (ext4) und <em>agcount</em> (XFS) passend wÃ¤hlen.</li>
<li><strong>Snapshots:</strong> LVMâ€‘Snapshots vs. Btrfsâ€‘Snapshots â€“ Useâ€‘Case entscheidet.</li>
</ul>
<pre><code>mkfs.ext4 -E stride=128,stripe-width=512 /dev/md0
tune2fs -l /dev/md0 | grep -i stripe
            </code></pre>
</div></div>
<div class="card block"><h3>Benchmarking</h3><div class="card-body"><pre><code>
# dd (grobe Tendenz, Cache beachten)
dd if=/dev/zero of=/data/test.img bs=1G count=2 oflag=direct
#
# fio: realistische Workloads
fio --name=randread --filename=/data/testfile --size=2G \
    --rw=randread --bs=4k --iodepth=32 --numjobs=4 --direct=1 --time_based --runtime=60
#
fio --name=seqwrite --filename=/data/testfile --size=10G \
    --rw=write --bs=1M --iodepth=16 --numjobs=1 --direct=1 --runtime=60
          </code></pre><p>Hinweise: identische Hardware, Caches/FreiberÃ¤ume angleichen, gleiche Mountâ€‘Optionen, mehrere LÃ¤ufe mitteln.</p></div></div>
<div class="card block"><h3>Typische Fallstricke</h3><div class="card-body"><ul>
<li><strong>ext4 data=writeback:</strong> hÃ¶heres Korruptionsrisiko nach Crash â€“ nur wissentlich.</li>
<li><strong>XFS + viele kleine Dateien:</strong> Metadatenâ€‘Overhead; ggf. ext4 prÃ¼fen.</li>
<li><strong>Btrfs Fragmentierung:</strong> Randomâ€‘Writes + COW â†’ <code>autodefrag</code> testen; fÃ¼r groÃŸe Images <code>nodatacow</code>.</li>
<li><strong>TRIM/Discard:</strong> periodisches <code>fstrim.timer</code> bevorzugen.</li>
<li><strong>Falsches Alignment:</strong> RAID/SSDâ€‘Mismatch kostet stark.</li>
</ul></div></div>
<div class="card block"><h3>Quiz</h3><div class="card-body">
<div class="quiz" id="quiz-fs-1">
<div class="quiz-question">Welches Dateisystem ist typischerweise ideal fÃ¼r sehr groÃŸe, sequentielle Dateien und hohe ParallelitÃ¤t?</div>
<div class="quiz-options">
<label class="quiz-option"><input name="fs1" type="radio"/> ext4</label>
<label class="quiz-option" data-correct="1"><input name="fs1" type="radio"/> XFS</label>
<label class="quiz-option"><input name="fs1" type="radio"/> FAT</label>
</div>
<div class="quiz-actions"><button class="btn primary check-quiz">PrÃ¼fen</button></div>
<div class="quiz-feedback"></div>
</div>
<div class="quiz" id="quiz-fs-2">
<div class="quiz-question">Welche Aussage trifft fÃ¼r Btrfs im Standardbetrieb am ehesten zu?</div>
<div class="quiz-options">
<label class="quiz-option" data-correct="1"><input name="fs2" type="radio"/> COW, Snapshots und Kompression kÃ¶nnen Readâ€‘Lasten verbessern.</label>
<label class="quiz-option"><input name="fs2" type="radio"/> Keine PrÃ¼fsummen vorhanden.</label>
<label class="quiz-option"><input name="fs2" type="radio"/> Btrfs unterstÃ¼tzt keine Quotas.</label>
</div>
<div class="quiz-actions"><button class="btn primary check-quiz">PrÃ¼fen</button></div>
<div class="quiz-feedback"></div>
</div>
</div></div>
<div class="card block"><h3>Ãœbungen</h3><div class="card-body"><ol>
<li>Erstellen Sie eine XFSâ€‘Partition und vergleichen Sie Kopierzeiten groÃŸer Dateien (â‰¥5 GB) mit ext4. Dokumentieren Sie die Mountâ€‘Optionen.</li>
<li>Legen Sie auf Btrfs zwei Subvolumes an (<code>@root</code>, <code>@data</code>), aktivieren Sie <code>compress=zstd</code> und erstellen Sie einen Snapshot. Messen Sie Platzbedarf mit <code>btrfs filesystem du</code>.</li>
<li>Welche Risiken hat <code>data=writeback</code> bei ext4? Reproduzieren Sie einen Stromausfallâ€‘Test in einer VM (Vorsicht!).</li>
</ol></div></div>
<div class="card block"><h3>PrÃ¼fungsfragen</h3><div class="card-body"><ol>
<li>Welches Dateisystem eignet sich typischerweise fÃ¼r Workloads mit sehr groÃŸen, sequentiellen Dateien? BegrÃ¼nden Sie.</li>
<li>Nennen Sie zwei Vorteile von Btrfs gegenÃ¼ber ext4 und ein Szenario, in dem ext4 die bessere Wahl ist.</li>
<li>Welche Mountâ€‘Option vermindert unnÃ¶tige Schreibzugriffe bei hÃ¤ufigen Dateiâ€‘Reads? Welche Nebenwirkungen hat sie?</li>
</ol></div></div>
<div class="card block"><h3>Deepâ€‘Dive: ext4</h3><div class="card-body">
<p><strong>Struktur:</strong> extentsâ€‘basierte Allokation, HTreeâ€‘Indizes fÃ¼r Verzeichnisse, Journal (JBD2) fÃ¼r Metadaten, optional Datenjournal.</p>
<ul>
<li><strong>Journalingâ€‘Modi:</strong> <code>data=ordered</code> (Default, Daten vor Metadaten), <code>writeback</code> (schneller, riskanter), <code>journal</code> (sicher, langsam).</li>
<li><strong>Delayed Allocation:</strong> bessere Extentâ€‘ZusammenhÃ¤ngigkeit, kann bei Crashes zu 0â€‘Byteâ€‘Files fÃ¼hren (Daten nicht im Journal).</li>
<li><strong>Featureâ€‘Flags:</strong> <code>64bit</code>, <code>metadata_csum</code>, <code>dir_index</code>, <code>extent</code> â€“ mit <code>tune2fs -l</code> prÃ¼fen.</li>
</ul>
<pre><code># Diagnose
sudo dumpe2fs -h /dev/sdb1 | sed -n '1,50p'
# Verzeichnisindizes aktivieren
sudo tune2fs -O dir_index /dev/sdb1 &amp;&amp; sudo e2fsck -Df /dev/sdb1
# Journalâ€‘Commit Intervall anpassen (Ã¼ber Mount)
sudo mount -o remount,commit=60,noatime /data
            </code></pre>
</div></div>
<div class="card block"><h3>Deepâ€‘Dive: XFS</h3><div class="card-body">
<p><strong>Design:</strong> Allocation Groups (AGs) fÃ¼r ParallelitÃ¤t, B+â€‘Trees fÃ¼r freie Extents, Journal (Log) in separaten Regionen.</p>
<ul>
<li><strong>StÃ¤rken:</strong> sehr gute Skalierung bei groÃŸen Dateien, parallele IO, Onlineâ€‘Defragmentierung.</li>
<li><strong>Hinweise:</strong> weniger effizient bei Millionen sehr kleiner Dateien; RAMâ€‘bedarf fÃ¼r Metadatenâ€‘Caches beachten.</li>
<li><strong>Trim:</strong> bevorzugt periodisch via <code>fstrim.timer</code> statt dauerhaftem <code>discard</code>.</li>
</ul>
<pre><code># Layout/Infos
sudo xfs_info /media
# Freiraum/Fragmentierung analysieren
sudo xfs_spaceman -c 'frag -v' /media
# Onlineâ€‘Defrag (Datei/Verzeichnis)
sudo xfs_fsr -v /media/schwere_datei
            </code></pre>
</div></div>
<div class="card block"><h3>Deepâ€‘Dive: Btrfs</h3><div class="card-body">
<p><strong>COWâ€‘basierte Architektur:</strong> nahezu alle Strukturen als Bâ€‘Trees; Subvolumes als eigenstÃ¤ndige Wurzeln; eingebaute Checksums fÃ¼r Daten/Metadaten.</p>
<ul>
<li><strong>Snapshots/Send:</strong> schnelle, platzsparende Snapshots; Replikation via <code>btrfs send/receive</code>.</li>
<li><strong>RAIDâ€‘Profile:</strong> <code>single</code>, <code>dup</code> (nur Metadaten), <code>raid1/10/5/6</code> â€“ 5/6 erfordern aktuelles Kernel/Tools und VerstÃ¤ndnis von Writeâ€‘Hole/ParitÃ¤tsâ€‘Rebuilds.</li>
<li><strong>Fragmentierung:</strong> Randomâ€‘Writes + COW â†’ <code>autodefrag</code> testen; fÃ¼r VM/DB <code>nodatacow</code> (per Subvolume/Attribute <code>chattr +C</code>).</li>
</ul>
<pre><code># Subvolumes und Snapshots
sudo btrfs subvolume create /mnt/@home
sudo btrfs subvolume snapshot -r /mnt/@root /mnt/@root-$(date +%F)
# Balance gezielt (nicht blind)
sudo btrfs balance start -dusage=75 -musage=75 /mnt
# Scrub (IntegritÃ¤tsprÃ¼fung)
sudo btrfs scrub start -B /mnt
            </code></pre>
</div></div>
<div class="card block"><h3>Migration &amp; Konvertierung</h3><div class="card-body">
<ul>
<li><strong>ext4 â†’ XFS/Btrfs:</strong> klassisch per rsync/restore. Beispiel: Liveâ€‘System von <code>/</code> auf neues FS migrieren mittels Rescueâ€‘Medium.</li>
<li><strong>Btrfs Subvolâ€‘Layout:</strong> <code>@root</code>, <code>@home</code>, <code>@log</code>, <code>@containers</code>; getrennte Mountâ€‘Optionen pro Subvolume.</li>
<li><strong>UUID/Labels:</strong> nach Migration <code>/etc/fstab</code> aktualisieren; <code>lsblk -f</code> und <code>blkid</code> prÃ¼fen.</li>
</ul>
<pre><code># Rsyncâ€‘Migrationsmuster
sudo rsync -aAXHv --numeric-ids --exclude={'/dev/*','/proc/*','/sys/*','/tmp/*','/run/*','/mnt/*','/media/*','/lost+found'} / /mnt/@root/
            </code></pre>
</div></div>
<div class="card block"><h3>Monitoring &amp; Health</h3><div class="card-body">
<ul>
<li><strong>SMART/PHY:</strong> <code>smartctl -a /dev/sdX</code>, Temperaturen/FehlerzÃ¤hler prÃ¼fen.</li>
<li><strong>ext4:</strong> regelmÃ¤ÃŸige <code>e2fsck</code> (offline) je nach Einsatz; <code>tune2fs -l</code> fÃ¼r Mountâ€‘Counts/Intervalle.</li>
<li><strong>XFS:</strong> <code>xfs_repair -n</code> (Readâ€‘only Check) vor Offlineâ€‘Repair.</li>
<li><strong>Btrfs:</strong> <code>btrfs scrub</code> zyklisch, <code>btrfs device stats</code>, <code>btrfs check</code> nur offline und mit Vorsicht.</li>
</ul>
</div></div>
<div class="card block"><h3>Troubleshooting</h3><div class="card-body">
<ul>
<li><strong>ext4 orphan inodes:</strong> nach Crash normal; <code>e2fsck -f</code> repariert. PrÃ¼fen, ob <code>writeback</code> aktiv war.</li>
<li><strong>XFS Metadataâ€‘Corruption:</strong> Logs sichern; erst <code>xfs_repair -n</code>, dann ohne <code>-n</code> im Maintenanceâ€‘Fenster.</li>
<li><strong>Btrfs ENOSPC trotz Freiraum:</strong> Metadaten erschÃ¶pft; gezielte Balance (<code>-musage</code>), Snapshots aufrÃ¤umen, <code>btrfs filesystem df</code> prÃ¼fen.</li>
<li><strong>Mount hÃ¤ngt langsam:</strong> Netzwerkâ€‘/uDisksâ€‘Timeouts, defekte GerÃ¤te, fehlerhafte <code>/etc/fstab</code> Optionen (<code>nofail</code>, <code>x-systemd.device-timeout=</code> erwÃ¤gen).</li>
</ul>
</div></div>
<div class="card block"><h3>Sicherheit &amp; IntegritÃ¤t</h3><div class="card-body">
<ul>
<li><strong>Checksums:</strong> Btrfs/ZFS erkennen stille Bitfehler, ext4/XFS nicht â€“ erwÃ¤ge RAID, ECCâ€‘RAM, zeitnahe Backups.</li>
<li><strong>VerschlÃ¼sselung:</strong> LUKS unterhalb des FS; Interaktion mit COW (Btrfs) und TRIM (<code>discard, fstrim</code>) verstehen.</li>
<li><strong>Forensik:</strong> Journale kÃ¶nnen Artefakte enthalten; Readâ€‘only Mounts (<code>-o ro,noload</code> bei ext4/XFS) fÃ¼r Analysen.</li>
</ul>
<pre><code># Readâ€‘only ohne Journalâ€‘Replays
sudo mount -t ext4 -o ro,noload /dev/sdb1 /mnt
sudo mount -t xfs  -o ro,norecovery /dev/sdc1 /mnt
            </code></pre>
</div></div>
<div class="card block"><h3>Praxisâ€‘Szenarien</h3><div class="card-body">
<ul>
<li><strong>Medienserver (NVMe + HDDâ€‘Tiering):</strong> XFS auf NVMe fÃ¼r Transcode/Cache, ext4/XFS auf HDD fÃ¼r Archiv; wÃ¶chentliches <code>fstrim</code>.</li>
<li><strong>Devâ€‘Workstation:</strong> Btrfs mit <code>@root/@home</code>, Snapshots vor Systemâ€‘Upgrades, <code>compress=zstd</code>.</li>
<li><strong>Backupâ€‘Repository:</strong> XFS oder ZFS; immutables durch Snapshots/Sendâ€‘Receive; Offsiteâ€‘Replikation.</li>
</ul>
</div></div>
<div class="card block"><h3>Glossar</h3><div class="card-body">
<dl>
<dt>Extent</dt><dd>ZusammenhÃ¤ngender Blockbereich, reduziert Fragmentierung/Metadaten.</dd>
<dt>COW</dt><dd>Copyâ€‘onâ€‘Write: Ã„nderungen werden in neue BlÃ¶cke geschrieben, alte bleiben bis Commit unverÃ¤ndert.</dd>
<dt>Scrub</dt><dd>IntegritÃ¤tsprÃ¼fung mit Reparaturversuch aus Redundanz.</dd>
</dl>
</div></div>
<div class="card block"><h3>WeiterfÃ¼hrende Links</h3><div class="card-body">
<ul>
<li>Kernel Docs: ext4, XFS, Btrfs (docs.kernel.org)</li>
<li>Btrfs Wiki (btrfs.wiki.kernel.org)</li>
<li>XFS Documentation (xfs.org, manâ€‘Pages)</li>
</ul>
</div></div>
</article>
</div>
<div class="card" id="progressWidget"><div class="card-body"><h3>Kapitel abschlieÃŸen</h3><p class="muted">Hake dieses Kapitel als erledigt ab. Dein Fortschritt wird nur lokal im Browser gespeichert.</p><label class="checkbox"><input id="pageComplete" type="checkbox"/> Ich habe dieses Kapitel verstanden</label><p><a href="../../lpic-1/fortschritt.html">Zu meinem Fortschritt</a></p></div></div><div class="card"><div class="card-body"><h3>Vertiefung &amp; Praxis</h3><p><strong>Vertiefung:</strong> Wichtige Praxisaspekte und PrÃ¼fungsbezug.</p>
<ul><li>Relevante Manpages, typische Optionen und Nebeneffekte.</li><li>PraxisÃ¼bung in einer frischen VM; Ã„nderungen reproduzierbar dokumentieren.</li><li>PrÃ¼fungsszenarien mit Stolpersteinen und Zeitsparâ€‘Tricks.</li></ul></div></div><div class="card"><div class="card-body"><h3>Checkliste â€“ schneller Durchblick</h3>
<ul>
<li>Relevante Logdateien geprÃ¼ft? (<code>journalctl</code>, <code>/var/log/*</code>)</li>
<li>Manpage/--help gelesen und Option bewusst gewÃ¤hlt?</li>
<li>Rechte/Ownership/SELinux/AppArmor berÃ¼cksichtigt?</li>
<li>Distribution &amp; Version: gleiches Verhalten verifiziert?</li>
</ul>
</div></div><div class="card"><div class="card-body"><h3>PrÃ¼fungsfragen (MC)</h3><h3>Quiz â€“ Selbsttest</h3><div class="card"><div class="card-body"><p><strong>Frage:</strong> Welche Manpage zeigt Synopsis &amp; Optionen eines Befehls?</p><ol><li><strong>A.</strong> info</li><li><strong>B.</strong> help</li><li><strong>C.</strong> man</li><li><strong>D.</strong> what</li></ol><details><summary>LÃ¶sung anzeigen</summary><p><strong>Richtig:</strong> C. man ist Standardreferenz.</p></details></div></div></div></div><div class="card"><div class="card-body"><h3>Optionenâ€‘Atlas (Kernbefehle)</h3><table><tr><th>Kommando</th><th>Wichtige Optionen</th></tr><tr><td><code>man</code></td><td>man 1 chmod; man -k KEYWORD; /Suchbegriff; n weiter</td></tr>
<tr><td><code>help</code></td><td>Bash builtins: help test; type zeigt Herkunft</td></tr>
<tr><td><code>info</code></td><td>Detailierte Doku via Info-Seiten</td></tr></table></div></div><div class="card"><div class="card-body"><h3>Szenarien aus der Praxis</h3><ul><li>Manpages effektiv: SYNOPSIS â†’ Optionen â†’ EXAMPLES; eigene Notizen ans Ende der Seite.</li>
<li>Vor Ã„nderung: Backup der Konfig und spÃ¤ter diff zum Vergleichen.</li>
<li>Alle Schritte in Readme im Repo dokumentieren (Wiederholbarkeit).</li></ul></div></div><div class="card"><div class="card-body"><h3>Diagnose-Flow (schneller Pfad zur LÃ¶sung)</h3><ol><li>Reproduktion in frischer VM mÃ¶glich?</li>
<li>Ã„nderung minimal &amp; dokumentiert?</li>
<li>Fallback/Backoutâ€‘Plan vorhanden?</li>
<li>Securityâ€‘Implikationen bedacht?</li></ol></div></div><div class="card"><div class="card-body"><h3>Erweiterte Ãœbungen</h3><p>Bearbeite die Aufgaben, dokumentiere die Schritte und vergleiche die Ergebnisse mit den Erwartungen. Nutze eine frische VM fÃ¼r reproduzierbare Ergebnisse.</p><ol><li>Manpages effektiv: SYNOPSIS â†’ Optionen â†’ EXAMPLES; eigene Notizen ans Ende der Seite. â€“ <em>liefere Befehle, BegrÃ¼ndung und Nachweise (Logs/Outputs)</em>.</li><li>Vor Ã„nderung: Backup der Konfig und spÃ¤ter diff zum Vergleichen. â€“ <em>liefere Befehle, BegrÃ¼ndung und Nachweise (Logs/Outputs)</em>.</li><li>Alle Schritte in Readme im Repo dokumentieren (Wiederholbarkeit). â€“ <em>liefere Befehle, BegrÃ¼ndung und Nachweise (Logs/Outputs)</em>.</li></ol></div></div><div class="card"><div class="card-body"><h3>Cheatsheet â€“ erweitert</h3><pre><code># NÃ¼tzliche Helfer
man -k backup
type chmod
info coreutils 'File permissions'</code></pre></div></div><div class="card" id="prevnext"><div class="card-body"><h3>Weiter navigieren</h3><p><a href="dateisystem-attribute.html" rel="prev">â† Vorherige Seite</a> Â· <a href="dateisystem-werkzeuge.html" rel="next">NÃ¤chste Seite â†’</a></p></div></div></main>
<footer class="site-footer"><div class="container"><span>Â© Linux Lernportal</span></div></footer>
</body>
</html>
